import Color from "./Color";
import Trigger from "./Trigger";
import Sound, { EffectChain, AudioEffectMap } from "./Sound";
import Costume from "./Costume";
import type { Mouse } from "./Input";
import type Project from "./Project";
import type Watcher from "./Watcher";
import type { Yielding } from "./lib/yielding";
import { effectNames } from "./renderer/effectInfo";
type Effects = {
    [x in typeof effectNames[number]]: number;
};
export declare class _EffectMap implements Effects {
    _bitmask: number;
    private _effectValues;
    color: number;
    fisheye: number;
    whirl: number;
    pixelate: number;
    mosaic: number;
    brightness: number;
    ghost: number;
    constructor();
    _clone(): _EffectMap;
    clear(): void;
}
export type SpeechBubbleStyle = "say" | "think";
export type SpeechBubble = {
    text: string;
    style: SpeechBubbleStyle;
    timeout: number | null;
};
type InitialConditions = {
    costumeNumber: number;
    layerOrder?: number;
};
declare abstract class SpriteBase {
    protected _project: Project;
    protected _costumeNumber: number;
    protected _layerOrder: number;
    triggers: Trigger[];
    watchers: Partial<Record<string, Watcher>>;
    protected costumes: Costume[];
    protected sounds: Sound[];
    protected effectChain: EffectChain;
    effects: _EffectMap;
    audioEffects: AudioEffectMap;
    protected _vars: object;
    constructor(initialConditions: InitialConditions, vars?: {});
    protected getSoundsPlayedByMe(): Sound[];
    get stage(): Stage;
    get sprites(): Partial<Record<string, Sprite>>;
    get vars(): object;
    get costumeNumber(): number;
    set costumeNumber(number: number);
    set costume(costume: number | string | Costume);
    get costume(): Costume;
    degToRad(deg: number): number;
    radToDeg(rad: number): number;
    degToScratch(deg: number): number;
    scratchToDeg(scratchDir: number): number;
    radToScratch(rad: number): number;
    scratchToRad(scratchDir: number): number;
    scratchTan(angle: number): number;
    normalizeDeg(deg: number): number;
    wrapClamp(n: number, min: number, max: number): number;
    warp(procedure: GeneratorFunction): (...args: unknown[]) => void;
    random(a: number, b: number): number;
    wait(secs: number): Yielding<void>;
    get mouse(): Mouse;
    keyPressed(name: string): boolean;
    get timer(): number;
    restartTimer(): void;
    startSound(soundName: string): Yielding<void>;
    playSoundUntilDone(soundName: string): Yielding<void>;
    getSound(soundName: string): Sound | undefined;
    stopAllSounds(): void;
    stopAllOfMySounds(): void;
    broadcast(name: string): Promise<void>;
    broadcastAndWait(name: string): Yielding<void>;
    clearPen(): void;
    askAndWait(question: string): Yielding<void>;
    get answer(): string | null;
    get loudness(): number;
    toNumber(value: unknown): number;
    toBoolean(value: unknown): boolean;
    toString(value: unknown): string;
    stringIncludes(string: string, substring: string): boolean;
    arrayIncludes<T>(array: T[], value: T): boolean;
    letterOf(string: string, index: number): string;
    itemOf<T>(array: T[], index: number): T | "";
    indexInArray<T>(array: T[], value: T): number;
    compare(v1: unknown, v2: unknown): number;
}
type RotationStyle = typeof Sprite["RotationStyle"][keyof typeof Sprite["RotationStyle"]];
type SpriteInitialConditions = {
    x: number;
    y: number;
    direction: number;
    rotationStyle?: RotationStyle;
    costumeNumber: number;
    size: number;
    visible: boolean;
    penDown?: boolean;
    penSize?: number;
    penColor?: Color;
};
export declare class Sprite extends SpriteBase {
    private _x;
    private _y;
    private _direction;
    rotationStyle: RotationStyle;
    size: number;
    visible: boolean;
    private parent;
    clones: this[];
    private _penDown;
    penSize: number;
    private _penColor;
    _speechBubble?: SpeechBubble;
    constructor(initialConditions: SpriteInitialConditions, vars?: {});
    askAndWait(question: string): Yielding<void>;
    createClone(): void;
    deleteThisClone(): void;
    andClones(): this[];
    get direction(): number;
    set direction(dir: number);
    goto(x: number, y: number): void;
    get x(): number;
    set x(x: number);
    get y(): number;
    set y(y: number);
    move(dist: number): void;
    glide(seconds: number, x: number, y: number): Yielding<void>;
    moveAhead(value?: number | Sprite): void;
    moveBehind(value?: number | Sprite): void;
    get penDown(): boolean;
    set penDown(penDown: boolean);
    get penColor(): Color;
    set penColor(color: unknown);
    stamp(): void;
    touching(target: "mouse" | "edge" | Sprite | Stage, fast?: boolean): boolean;
    colorTouching(color: Color, target: Sprite | Stage): boolean;
    say(text: string): void;
    think(text: string): void;
    sayAndWait(text: string, seconds: number): Yielding<void>;
    thinkAndWait(text: string, seconds: number): Yielding<void>;
    static RotationStyle: Readonly<{
        ALL_AROUND: symbol;
        LEFT_RIGHT: symbol;
        DONT_ROTATE: symbol;
    }>;
}
type StageInitialConditions = {
    width?: number;
    height?: number;
} & InitialConditions;
export declare class Stage extends SpriteBase {
    readonly width: number;
    readonly height: number;
    __counter: number;
    constructor(initialConditions: StageInitialConditions, vars?: {});
    fireBackdropChanged(): Promise<void>;
    get costumeNumber(): number;
    set costumeNumber(number: number);
}
export {};
